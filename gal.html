<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1"
    />
    <title>Photo Gallery — Google Photos style (vanilla)</title>
    <style>
      :root {
        --bg: #0b0b0c;
        --accent: #ffffff;
        --toolbar: rgba(0, 0, 0, 0.5);
        --thumb-size: 64px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
      }
      body {
        background: linear-gradient(180deg, #050505, #0f0f10);
        color: var(--accent);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      /* Simple grid gallery */
      .gallery {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 12px;
        width: 100%;
        max-width: 1100px;
      }
      .thumb {
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        background: #111;
        cursor: pointer;
        aspect-ratio: 4/3;
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transform-origin: center center;
        transition: transform 0.35s ease;
      }
      .thumb:active img {
        transform: scale(0.98);
      }

      /* Viewer modal */
      .viewer {
        position: fixed;
        inset: 0;
        background: rgba(6, 6, 6, 0.92);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .viewer.open {
        display: flex;
      }
      .viewer-inner {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
        touch-action: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Image container that will be transformed */
      .pic-wrap {
        will-change: transform;
        touch-action: none;
        display: flex;
        align-items: center;
        justify-content: center;
        max-width: 100%;
        max-height: 100%;
      }
      .pic-wrap img {
        max-width: 100%;
        max-height: 100%;
        user-select: none;
        pointer-events: none;
        display: block;
      }

      /* Toolbar */
      .topbar {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.45), transparent);
        z-index: 5;
      }
      .toolbar-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .btn {
        background: var(--toolbar);
        color: var(--accent);
        padding: 8px 10px;
        border-radius: 8px;
        border: 0;
        backdrop-filter: blur(4px);
        cursor: pointer;
      }

      /* Footer thumbs */
      .thumbs {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 18px;
        display: flex;
        gap: 8px;
        padding: 8px;
        border-radius: 12px;
        z-index: 5;
        background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.4));
      }
      .thumbs button {
        width: var(--thumb-size);
        height: var(--thumb-size);
        padding: 0;
        border-radius: 10px;
        overflow: hidden;
        border: 2px solid transparent;
        background: #000;
      }
      .thumbs button img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .thumbs button.active {
        border-color: rgba(255, 255, 255, 0.85);
      }

      /* Navigation arrows */
      .nav {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 24px;
        z-index: 3;
        pointer-events: none;
      }
      .nav .side {
        pointer-events: auto;
        background: transparent;
        border-radius: 999px;
        padding: 16px;
      }
      .nav .side:active {
        transform: scale(0.96);
      }
      .icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.05);
        cursor: pointer;
      }

      /* instructions small */
      .hint {
        position: absolute;
        left: 12px;
        bottom: 12px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
      }

      /* Responsive */
      @media (max-width: 600px) {
        :root {
          --thumb-size: 48px;
        }
      }
    </style>
  </head>
  <body>
    <h2 style="margin: 6px 0 18px; text-align: center">
      Photo Gallery — Google Photos like (vanilla)
    </h2>

    <div class="gallery" id="gallery">
      <div class="thumb" data-index="0">
        <img src="assets/images/img20.jpg" alt="img20" />
      </div>
      <div class="thumb" data-index="1">
        <img src="assets/images/img21.jpg" alt="img21" />
      </div>
      <div class="thumb" data-index="2">
        <img src="assets/images/img22.jpg" alt="img22" />
      </div>
    </div>

    <!-- Viewer modal -->
    <div class="viewer" id="viewer" aria-hidden="true">
      <div class="viewer-inner" id="viewerInner">
        <div class="topbar">
          <div style="display: flex; align-items: center; gap: 12px">
            <button class="btn" id="closeBtn">Close</button>
            <div id="fileName" style="opacity: 0.9; font-size: 14px"></div>
          </div>
          <div class="toolbar-actions">
            <button class="btn" id="zoomReset">Reset</button>
            <button class="btn" id="downloadBtn">Download</button>
          </div>
        </div>

        <div class="pic-wrap" id="picWrap">
          <img id="viewerImg" src="" alt="open image" />
        </div>

        <div class="nav">
          <div class="side" id="prevBtn" title="Previous">
            <div class="icon">◀</div>
          </div>
          <div class="side" id="nextBtn" title="Next">
            <div class="icon">▶</div>
          </div>
        </div>

        <div class="thumbs" id="thumbStrip">
          <button data-index="0">
            <img src="assets/images/img20.jpg" alt="t0" />
          </button>
          <button data-index="1">
            <img src="assets/images/img21.jpg" alt="t1" />
          </button>
          <button data-index="2">
            <img src="assets/images/img22.jpg" alt="t2" />
          </button>
        </div>

        <div class="hint">
          Double-tap to zoom. Pinch to zoom. Drag to pan. Swipe to navigate.
        </div>
      </div>
    </div>

    <script>
      (function () {
        const imgs = [
          "assets/images/img20.jpg",
          "assets/images/img21.jpg",
          "assets/images/img22.jpg",
        ];

        // Elements
        const gallery = document.getElementById("gallery");
        const viewer = document.getElementById("viewer");
        const viewerImg = document.getElementById("viewerImg");
        const picWrap = document.getElementById("picWrap");
        const closeBtn = document.getElementById("closeBtn");
        const zoomReset = document.getElementById("zoomReset");
        const downloadBtn = document.getElementById("downloadBtn");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const thumbStrip = document.getElementById("thumbStrip");
        const fileName = document.getElementById("fileName");

        let index = 0;

        // transform state
        let scale = 1; // current scale
        let minScale = 1;
        let maxScale = 4;
        let translate = { x: 0, y: 0 };

        // pointer / touch state
        let isPointerDown = false;
        let lastPointer = { x: 0, y: 0 };
        let lastSingleTouchX = 0;
        let lastSingleTouchY = 0;
        let touchStartTime = 0;
        let lastTap = 0;

        // pinch state
        let pinching = false;
        let pinchStart = { dist: 0, scale: 1, mid: { x: 0, y: 0 } };

        // swipe state when not zoomed
        let swipe = { startX: 0, startY: 0, tracking: false };

        // preload
        imgs.forEach((src) => {
          const i = new Image();
          i.src = src;
        });

        // open viewer
        function open(i) {
          index = (i + imgs.length) % imgs.length;
          updateImage();
          viewer.classList.add("open");
          viewer.setAttribute("aria-hidden", "false");
          document.body.style.overflow = "hidden";
        }

        function close() {
          viewer.classList.remove("open");
          viewer.setAttribute("aria-hidden", "true");
          resetTransform();
          document.body.style.overflow = "auto";
        }

        function updateImage() {
          viewerImg.src = imgs[index];
          fileName.textContent = imgs[index].split("/").pop();
          // reset transforms for new image
          resetTransform();
          // update thumb active
          [...thumbStrip.children].forEach((b) =>
            b.classList.toggle("active", Number(b.dataset.index) === index)
          );
        }

        function resetTransform() {
          scale = 1;
          translate = { x: 0, y: 0 };
          updateTransform();
        }

        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }

        function updateTransform() {
          // We'll center image transform by translate and scale in picWrap
          picWrap.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;
        }

        // Wheel to zoom centered on cursor
        viewer.addEventListener(
          "wheel",
          (e) => {
            if (!viewer.classList.contains("open")) return;
            e.preventDefault();
            const rect = picWrap.getBoundingClientRect();
            const cx = e.clientX - rect.left - rect.width / 2; // center relative
            const cy = e.clientY - rect.top - rect.height / 2;
            const delta = -e.deltaY || e.wheelDelta;
            const factor = delta > 0 ? 1.12 : 0.88;
            const newScale = clamp(scale * factor, minScale, maxScale);
            // adjust translate so zoom is centered where cursor is
            translate.x = (translate.x - cx) * (newScale / scale) + cx;
            translate.y = (translate.y - cy) * (newScale / scale) + cy;
            scale = newScale;
            // if scaled back to 1, reset translate
            if (scale <= 1.001) {
              scale = 1;
              translate = { x: 0, y: 0 };
            }
            updateTransform();
          },
          { passive: false }
        );

        // Double click / double tap to toggle zoom
        viewer.addEventListener("dblclick", (e) => {
          e.preventDefault();
          const rect = picWrap.getBoundingClientRect();
          const cx = e.clientX - rect.left - rect.width / 2;
          const cy = e.clientY - rect.top - rect.height / 2;
          if (scale > 1.01) {
            resetTransform();
          } else {
            scale = 2.5; // jump zoom
            translate.x = -cx * (scale - 1);
            translate.y = -cy * (scale - 1);
            updateTransform();
          }
        });

        // Touch handling: support pinch to zoom and pan. Also single-touch swipe to navigate when not zoomed.
        viewer.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 1) {
              touchStartTime = Date.now();
              lastSingleTouchX = e.touches[0].clientX;
              lastSingleTouchY = e.touches[0].clientY;
              isPointerDown = true;
              isPanning = true;
              lastPointer.x = e.touches[0].clientX;
              lastPointer.y = e.touches[0].clientY;

              // double-tap detection
              const now = Date.now();
              if (now - lastTap < 300) {
                // double-tap
                const rect = picWrap.getBoundingClientRect();
                const cx = e.touches[0].clientX - rect.left - rect.width / 2;
                const cy = e.touches[0].clientY - rect.top - rect.height / 2;
                if (scale > 1.01) {
                  resetTransform();
                } else {
                  scale = 2.5;
                  translate.x = -cx * (scale - 1);
                  translate.y = -cy * (scale - 1);
                  updateTransform();
                }
                lastTap = 0;
              } else {
                lastTap = now;
              }

              // swipe start
              swipe.startX = e.touches[0].clientX;
              swipe.startY = e.touches[0].clientY;
              swipe.tracking = true;
            } else if (e.touches.length === 2) {
              pinching = true;
              swipe.tracking = false;
              isPointerDown = false;
              const [a, b] = [e.touches[0], e.touches[1]];
              pinchStart.dist = Math.hypot(
                a.clientX - b.clientX,
                a.clientY - b.clientY
              );
              pinchStart.scale = scale;
              pinchStart.mid = {
                x: (a.clientX + b.clientX) / 2,
                y: (a.clientY + b.clientY) / 2,
              };
            }
          },
          { passive: false }
        );

        viewer.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 1 && !pinching) {
              const t = e.touches[0];
              const dx = t.clientX - lastPointer.x;
              const dy = t.clientY - lastPointer.y;
              lastPointer.x = t.clientX;
              lastPointer.y = t.clientY;

              if (scale > 1.01) {
                // pan
                translate.x += dx;
                translate.y += dy;
                updateTransform();
              } else if (swipe.tracking) {
                // allow move visual feedback while swiping between images
                const offset = t.clientX - swipe.startX;
                picWrap.style.transform = `translate(${offset}px, 0) scale(1)`;
              }
            } else if (e.touches.length === 2) {
              e.preventDefault();
              const [a, b] = [e.touches[0], e.touches[1]];
              const dist = Math.hypot(
                a.clientX - b.clientX,
                a.clientY - b.clientY
              );
              const mid = {
                x: (a.clientX + b.clientX) / 2,
                y: (a.clientY + b.clientY) / 2,
              };
              const factor = dist / pinchStart.dist;
              let newScale = clamp(
                pinchStart.scale * factor,
                minScale,
                maxScale
              );
              // adjust translate to center on midpoint
              const rect = picWrap.getBoundingClientRect();
              const cx = mid.x - rect.left - rect.width / 2;
              const cy = mid.y - rect.top - rect.height / 2;
              translate.x = (translate.x - cx) * (newScale / scale) + cx;
              translate.y = (translate.y - cy) * (newScale / scale) + cy;
              scale = newScale;
              updateTransform();
            }
          },
          { passive: false }
        );

        viewer.addEventListener("touchend", (e) => {
          if (pinching && e.touches.length < 2) {
            pinching = false;
          }
          if (e.touches.length === 0) {
            isPointerDown = false;
            swipe.tracking = false; // finalize swipe
            // if scale <=1.01 we might interpret a horizontal swipe to change image
            const nowX = lastPointer.x;
            const dx = lastPointer.x - swipe.startX; // if negative then moved left
            const absdx = Math.abs(dx);
            if (scale <= 1.01 && absdx > 80) {
              // trigger navigation
              if (dx < 0) nextImage();
              else prevImage();
            }
            // reset picWrap transform in case swipe visual was active
            updateTransform();
          }
        });

        // Mouse / pointer pan for desktop
        let isPanning = false;
        viewer.addEventListener("pointerdown", (e) => {
          if (e.pointerType === "mouse" && e.button !== 0) return;
          isPointerDown = true;
          isPanning = true;
          lastPointer.x = e.clientX;
          lastPointer.y = e.clientY;
          viewer.setPointerCapture(e.pointerId);
        });
        viewer.addEventListener("pointermove", (e) => {
          if (!isPanning || isPointerDown === false) return;
          const dx = e.clientX - lastPointer.x;
          const dy = e.clientY - lastPointer.y;
          lastPointer.x = e.clientX;
          lastPointer.y = e.clientY;
          if (scale > 1.01) {
            translate.x += dx;
            translate.y += dy;
            updateTransform();
          }
        });
        viewer.addEventListener("pointerup", (e) => {
          isPointerDown = false;
          isPanning = false;
        });
        viewer.addEventListener("pointercancel", (e) => {
          isPointerDown = false;
          isPanning = false;
        });

        // Navigation
        function prevImage() {
          index = (index - 1 + imgs.length) % imgs.length;
          updateImage();
        }
        function nextImage() {
          index = (index + 1) % imgs.length;
          updateImage();
        }

        prevBtn.addEventListener("click", prevImage);
        nextBtn.addEventListener("click", nextImage);

        // keyboard
        document.addEventListener("keydown", (e) => {
          if (!viewer.classList.contains("open")) return;
          if (e.key === "Escape") close();
          if (e.key === "ArrowLeft") prevImage();
          if (e.key === "ArrowRight") nextImage();
          if (e.key === "+" || e.key === "=") {
            scale = clamp(scale * 1.12, minScale, maxScale);
            updateTransform();
          }
          if (e.key === "-") {
            scale = clamp(scale * 0.88, minScale, maxScale);
            if (scale <= 1.001) resetTransform();
            updateTransform();
          }
        });

        // thumbnail clicks
        thumbStrip.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          if (!btn) return;
          open(Number(btn.dataset.index));
        });

        // gallery thumb open
        gallery.addEventListener("click", (e) => {
          const t = e.target.closest(".thumb");
          if (!t) return;
          open(Number(t.dataset.index));
        });

        // Close and toolbar
        closeBtn.addEventListener("click", close);
        zoomReset.addEventListener("click", resetTransform);
        downloadBtn.addEventListener("click", () => {
          const a = document.createElement("a");
          a.href = viewerImg.src;
          a.download = viewerImg.src.split("/").pop();
          document.body.appendChild(a);
          a.click();
          a.remove();
        });

        // clicking outside image closes
        viewer.addEventListener("click", (e) => {
          if (
            e.target === viewer ||
            e.target === viewer.querySelector(".viewer-inner")
          )
            close();
        });

        // Prevent image dragging
        viewerImg.addEventListener("dragstart", (e) => e.preventDefault());

        // Expose some helpers for styling / testing
        window._gallery = { open, close, nextImage, prevImage };

        // initial thumb highlight
        updateImage();

        // ensure transform snaps back into bounds when image is released
        function ensureBounds() {
          // simplistic bounds: if scaled content smaller than container, center it
          if (scale <= 1) {
            translate = { x: 0, y: 0 };
            updateTransform();
            return;
          }
          // For simplicity we'll allow some freedom but clamp to a large safe range
          const rect = picWrap.getBoundingClientRect();
          const wrapW = rect.width;
          const wrapH = rect.height;
          // compute max offcenter allowed (very naive but works for typical photo sizes)
          const maxOffX = Math.max(0, (wrapW * (scale - 1)) / 2 + 20);
          const maxOffY = Math.max(0, (wrapH * (scale - 1)) / 2 + 20);
          translate.x = clamp(translate.x, -maxOffX, maxOffX);
          translate.y = clamp(translate.y, -maxOffY, maxOffY);
          updateTransform();
        }

        // call ensureBounds on pointer up and touchend
        viewer.addEventListener("pointerup", ensureBounds);
        viewer.addEventListener("pointercancel", ensureBounds);
        viewer.addEventListener("touchend", ensureBounds);
      })();
    </script>
  </body>
</html>
